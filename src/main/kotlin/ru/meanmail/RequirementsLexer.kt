package ru.meanmail

import com.intellij.lexer.FlexLexer
import com.intellij.psi.TokenType.BAD_CHARACTER
import com.intellij.psi.tree.IElementType
import ru.meanmail.psi.Types.Companion.AND
import ru.meanmail.psi.Types.Companion.AT
import ru.meanmail.psi.Types.Companion.COLON
import ru.meanmail.psi.Types.Companion.COMMA
import ru.meanmail.psi.Types.Companion.COMMENT
import ru.meanmail.psi.Types.Companion.DIGIT
import ru.meanmail.psi.Types.Companion.DOLLAR_SIGN
import ru.meanmail.psi.Types.Companion.DOT
import ru.meanmail.psi.Types.Companion.DQUOTE
import ru.meanmail.psi.Types.Companion.EDITABLE
import ru.meanmail.psi.Types.Companion.ENV_VAR
import ru.meanmail.psi.Types.Companion.EOL
import ru.meanmail.psi.Types.Companion.IDENTIFIER
import ru.meanmail.psi.Types.Companion.IN
import ru.meanmail.psi.Types.Companion.LBRACE
import ru.meanmail.psi.Types.Companion.LETTER
import ru.meanmail.psi.Types.Companion.LPARENTHESIS
import ru.meanmail.psi.Types.Companion.LSBRACE
import ru.meanmail.psi.Types.Companion.MINUS
import ru.meanmail.psi.Types.Companion.NOT
import ru.meanmail.psi.Types.Companion.OR
import ru.meanmail.psi.Types.Companion.PERCENT_SIGN
import ru.meanmail.psi.Types.Companion.PLUS
import ru.meanmail.psi.Types.Companion.PYTHON_STR_C
import ru.meanmail.psi.Types.Companion.QUESTION_MARK
import ru.meanmail.psi.Types.Companion.RBRACE
import ru.meanmail.psi.Types.Companion.REFER
import ru.meanmail.psi.Types.Companion.RPARENTHESIS
import ru.meanmail.psi.Types.Companion.RSBRACE
import ru.meanmail.psi.Types.Companion.SEMICOLON
import ru.meanmail.psi.Types.Companion.SHARP
import ru.meanmail.psi.Types.Companion.SLASH
import ru.meanmail.psi.Types.Companion.SQUOTE
import ru.meanmail.psi.Types.Companion.SUB_DELIMS
import ru.meanmail.psi.Types.Companion.TILDA
import ru.meanmail.psi.Types.Companion.UNDERSCORE
import ru.meanmail.psi.Types.Companion.VERSION
import ru.meanmail.psi.Types.Companion.VERSION_CMP
import ru.meanmail.psi.Types.Companion.WHITE_SPACE
import java.io.Reader
import java.util.*

/**
 * This class is a scanner generated by
 * [JFlex](http://www.jflex.de/) 1.7.0
 * from the specification file <tt>RequirementsLexer.flex</tt>
 */
class RequirementsLexer
/**
 * Creates a new scanner
 *
 * @param   zzReader  the java.io.Reader to read input from.
 */
(private val zzReader: Reader?) : FlexLexer {

    /** the current state of the DFA  */
    private var zzState = 0
    /** the current lexical state  */
    private var zzLexicalState = YYINITIAL
    /** this buffer contains the current text to be matched and is
     * the source of the yytext() string  */
    private var zzBuffer: CharSequence = ""
    /** the textposition at the last accepting state  */
    private var zzMarkedPos = 0
    /** the current text position in the buffer  */
    private var zzCurrentPos = 0
    /** startRead marks the beginning of the yytext() string in the buffer  */
    private var zzStartRead = 0
    /** endRead marks the last character in the buffer, that has been read
     * from input  */
    private var zzEndRead = 0
    /**
     * zzAtBOL == true <=> the scanner is currently at the beginning of a line
     */
    private var zzAtBOL = true
    /** zzAtEOF == true <=> the scanner is at the EOF  */
    private var zzAtEOF = false
    /** denotes if the user-EOF-code has already been executed  */
    private var zzEOFDone = false

    override fun getTokenStart() = zzStartRead
    override fun getTokenEnd() = tokenStart + yylength()

    internal var stack: Deque<Int> = ArrayDeque<Int>()

    fun yypush(newState: Int) {
        yybegin(newState)
        stack.push(newState)
    }

    fun yypop(): Int {
        if (stack.size == 0) {
            yyinitial()
            return YYINITIAL
        }

        val state: Int = stack.pop()

        if (stack.peek() == null) {
            yyinitial()
        } else {
            yybegin(stack.peek())
        }

        return state
    }

    fun yyinitial() {
        stack.clear()
        yypush(YYINITIAL)
    }

    override fun reset(buffer: CharSequence, start: Int, end: Int,
                       initialState: Int) {
        zzBuffer = buffer
        zzStartRead = start
        zzMarkedPos = tokenStart
        zzCurrentPos = zzMarkedPos
        zzAtEOF = false
        zzAtBOL = true
        zzEndRead = end
        yybegin(initialState)
    }

    /**
     * Refills the input buffer.
     *
     * @return      `false`, iff there was new input.
     *
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    private fun zzRefill() = true

    /**
     * Returns the current lexical state.
     */
    override fun yystate(): Int {
        return zzLexicalState
    }


    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    override fun yybegin(newState: Int) {
        zzLexicalState = newState
    }

    /**
     * Returns the text matched by the current regular expression.
     */
    fun yytext(): CharSequence {
        return zzBuffer.subSequence(tokenStart, zzMarkedPos)
    }

    /**
     * Returns the character at position <tt>pos</tt> from the
     * matched text.
     *
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch.
     * A value from 0 to yylength()-1.
     *
     * @return the character at position pos
     */
    fun yycharat(pos: Int): Char {
        return zzBuffer[tokenStart + pos]
    }

    /**
     * Returns the length of the matched text region.
     */
    private fun yylength(): Int {
        return zzMarkedPos - tokenStart
    }

    /**
     * Reports an error that occurred while scanning.
     *
     * In a wellformed scanner (no or only correct usage of
     * yypushback(int) and a match-all fallback rule) this method
     * will only be called with things that "Can't Possibly Happen".
     * If this method is called, something is seriously wrong
     * (e.g. a JFlex bug producing a faulty scanner etc.).
     *
     * Usual syntax/scanner level error handling should be done
     * in error fallback rules.
     *
     * @param   errorCode  the code of the error message to display
     */
    private fun zzScanError(errorCode: Int) {
        throw Error(
                try {
                    ZZ_ERROR_MSG[errorCode]
                } catch (e: ArrayIndexOutOfBoundsException) {
                    ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR]
                }
        )
    }

    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * They will be read again by then next call of the scanning method
     *
     * @param number  the number of characters to be read again.
     * This number must not be greater than yylength()!
     */
    fun yypushback(number: Int) {
        if (number > yylength()) {
            zzScanError(ZZ_PUSHBACK_2BIG)
        }

        zzMarkedPos -= number
    }


    /**
     * Contains user EOF-code, which will be executed exactly once,
     * when the end of file is reached
     */
    private fun zzDoEOF() {
        if (!zzEOFDone) {
            zzEOFDone = true

        }
    }


    /**
     * Resumes scanning until the next regular expression is matched,
     * the end of input is encountered or an I/O-Error occurs.
     *
     * @return      the next token
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    override fun advance(): IElementType? {
        var zzInput: Int
        var zzAction: Int

        // cached fields:
        var zzCurrentPosL: Int
        var zzMarkedPosL: Int
        var zzEndReadL = zzEndRead
        var zzBufferL = zzBuffer

        val zzTransL = ZZ_TRANS
        val zzRowMapL = ZZ_ROWMAP
        val zzAttrL = ZZ_ATTRIBUTE

        while (true) {
            zzMarkedPosL = zzMarkedPos

            zzAction = -1

            zzStartRead = zzMarkedPosL
            zzCurrentPos = tokenStart
            zzCurrentPosL = zzCurrentPos

            zzState = ZZ_LEXSTATE[zzLexicalState]

            // set up zzAction for empty match case:
            var zzAttributes = zzAttrL[zzState]
            if (zzAttributes and 1 == 1) {
                zzAction = zzState
            }

            while (true) {
                if (zzCurrentPosL < zzEndReadL) {
                    zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL/*, zzEndReadL*/)
                    zzCurrentPosL += Character.charCount(zzInput)
                } else if (zzAtEOF) {
                    zzInput = YYEOF
                    break
                } else {
                    // store back cached positions
                    zzCurrentPos = zzCurrentPosL
                    zzMarkedPos = zzMarkedPosL
                    val eof = zzRefill()
                    // get translated positions and possibly new buffer
                    zzCurrentPosL = zzCurrentPos
                    zzMarkedPosL = zzMarkedPos
                    zzBufferL = zzBuffer
                    zzEndReadL = zzEndRead
                    if (eof) {
                        zzInput = YYEOF
                        break
                    } else {
                        zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL/*, zzEndReadL*/)
                        zzCurrentPosL += Character.charCount(zzInput)
                    }
                }
                val zzNext = zzTransL[zzRowMapL[zzState] + zzCmap(zzInput)]
                if (zzNext == -1) break
                zzState = zzNext

                zzAttributes = zzAttrL[zzState]
                if (zzAttributes and 1 == 1) {
                    zzAction = zzState
                    zzMarkedPosL = zzCurrentPosL
                    if (zzAttributes and 8 == 8) break
                }
            }

            // store back cached position
            zzMarkedPos = zzMarkedPosL

            if (zzInput == YYEOF && tokenStart == zzCurrentPos) {
                zzAtEOF = true
                zzDoEOF()
                when (zzLexicalState) {
                    ESCAPE_NEW_LINE -> {
                        yypop()
                        return EOL
                    } // fall though
                    172 -> {
                    }
                    else -> return null
                }
            } else {
                when (if (zzAction < 0) zzAction else ZZ_ACTION[zzAction]) {
                    1 -> {
                        return WHITE_SPACE
                    }
                    52 -> {
                    }
                    2 -> {
                        yyinitial()
                        return BAD_CHARACTER
                    }
                    53 -> {
                    }
                    3 -> {
                        return COMMENT
                    }
                    54 -> {
                    }
                    4 -> {
                        yypush(REQ)
                        yypushback(yylength())
                    }
                    55 -> {
                    }
                    5 -> {
                        yyinitial()
                        return EOL
                    }
                    56 -> {
                    }
                    6 -> {
                        yypop()
                        return VERSION
                    }
                    57 -> {
                    }
                    7 -> {
                        yypop()
                        return COMMENT
                    }
                    58 -> {
                    }
                    8 -> {
                        return PYTHON_STR_C
                    }
                    59 -> {
                    }
                    9 -> {
                        yypop()
                        return DQUOTE
                    }
                    60 -> {
                    }
                    10 -> {
                        yypop()
                        return SQUOTE
                    }
                    61 -> {
                    }
                    11 -> {
                        yyinitial()
                        return COMMENT
                    }
                    62 -> {
                    }
                    12 -> {
                        return VERSION_CMP
                    }
                    63 -> {
                    }
                    13 -> {
                        return LPARENTHESIS
                    }
                    64 -> {
                    }
                    14 -> {
                        return RPARENTHESIS
                    }
                    65 -> {
                    }
                    15 -> {
                        yypush(DQUOTE_STR)
                        return DQUOTE
                    }
                    66 -> {
                    }
                    16 -> {
                        yypush(SQUOTE_STR)
                        return SQUOTE
                    }
                    67 -> {
                    }
                    17 -> {
                        return PLUS
                    }
                    68 -> {
                    }
                    18 -> {
                        return MINUS
                    }
                    69 -> {
                    }
                    19 -> {
                        return SUB_DELIMS
                    }
                    70 -> {
                    }
                    20 -> {
                        return COLON
                    }
                    71 -> {
                    }
                    21 -> {
                        return QUESTION_MARK
                    }
                    72 -> {
                    }
                    22 -> {
                        return LSBRACE
                    }
                    73 -> {
                    }
                    23 -> {
                        return RSBRACE
                    }
                    74 -> {
                    }
                    24 -> {
                        return AT
                    }
                    75 -> {
                    }
                    25 -> {
                        return DOLLAR_SIGN
                    }
                    76 -> {
                    }
                    26 -> {
                        return SHARP
                    }
                    77 -> {
                    }
                    27 -> {
                        return PERCENT_SIGN
                    }
                    78 -> {
                    }
                    28 -> {
                        return SLASH
                    }
                    79 -> {
                    }
                    29 -> {
                        return DOT
                    }
                    80 -> {
                    }
                    30 -> {
                        return UNDERSCORE
                    }
                    81 -> {
                    }
                    31 -> {
                        return LBRACE
                    }
                    82 -> {
                    }
                    32 -> {
                        return RBRACE
                    }
                    83 -> {
                    }
                    33 -> {
                        return TILDA
                    }
                    84 -> {
                    }
                    34 -> {
                        return LETTER
                    }
                    85 -> {
                    }
                    35 -> {
                        return DIGIT
                    }
                    86 -> {
                    }
                    36 -> {
                        yypush(QUOTED_MARK)
                        return SEMICOLON
                    }
                    87 -> {
                    }
                    37 -> {
                        return COMMA
                    }
                    88 -> {
                    }
                    38 -> {
                        yypush(URI)
                        return AT
                    }
                    89 -> {
                    }
                    39 -> {
                        yypush(URI)
                        yypushback(yylength())
                    }
                    90 -> {
                    }
                    40 -> {
                        return IDENTIFIER
                    }
                    91 -> {
                    }
                    41 -> {
                        yypush(WAITING_VERSION)
                        return VERSION_CMP
                    }
                    92 -> {
                    }
                    42 -> {
                        yypop()
                        yypushback(yylength())
                    }
                    93 -> {
                    }
                    43 -> {
                        yypush(URI)
                        return EDITABLE
                    }
                    94 -> {
                    }
                    44 -> {
                        yypush(URI)
                        return REFER
                    }
                    95 -> {
                    }
                    45 -> {
                        return BAD_CHARACTER
                    }
                    96 -> {
                    }
                    46 -> {
                        yypush(ESCAPE_NEW_LINE)
                    }
                    97 -> {
                    }
                    47 -> {
                        return OR
                    }
                    98 -> {
                    }
                    48 -> {
                        return IN
                    }
                    99 -> {
                    }
                    49 -> {
                        return NOT
                    }
                    100 -> {
                    }
                    50 -> {
                        return AND
                    }
                    101 -> {
                    }
                    51 -> {
                        return ENV_VAR
                    }
                    102 -> {
                    }
                    else -> zzScanError(ZZ_NO_MATCH)
                }
            }
        }
    }

    companion object {

        /** This character denotes the end of file  */
        const val YYEOF = -1

        /** initial size of the lookahead buffer  */
        private const val ZZ_BUFFERSIZE = 16384

        /** lexical states  */
        const val YYINITIAL = 0
        const val WAITING_VERSION = 2
        const val DQUOTE_STR = 4
        const val SQUOTE_STR = 6
        const val QUOTED_MARK = 8
        const val URI = 10
        const val REQ = 12
        const val ESCAPE_NEW_LINE = 14
        /**
         * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
         * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
         * at the beginning of a line
         * l is of the form l = 2*k, k a non negative integer
         */
        private val ZZ_LEXSTATE = intArrayOf(
                0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7
        )

        /**
         * Translates characters to character classes
         * Chosen bits are [7, 7, 7]
         * Total runtime size is 1928 bytes
         */
        fun zzCmap(ch: Int): Int {
            return ZZ_CMAP_A[ZZ_CMAP_Y[ZZ_CMAP_Z[ch shr 14].toInt() or
                    (ch shr 7 and 0x7f)].toInt() shl 7 or
                    (ch and 0x7f)].toInt()
        }

        /* The ZZ_CMAP_Z table has 68 entries */
        private val ZZ_CMAP_Z = zzUnpackCMap(
                "\u0001\u0000\u0043\u0080")

        /* The ZZ_CMAP_Y table has 256 entries */
        private val ZZ_CMAP_Y = zzUnpackCMap(
                "\u0001\u0000\u0001\u0001\u002b\u0002\u0001\u0003\u0012\u0002\u0001\u0004\u001f\u0002\u0001\u0003\u009f\u0002")

        /* The ZZ_CMAP_A table has 640 entries */
        val ZZ_CMAP_A = zzUnpackCMap(
                "\u0009\u001d\u0001\u0000\u0001\u0018\u0002\u0019\u0001\u0018\u0012\u001d\u0001\u0000\u0001\u000a\u0001\u0034\u0001\u000d\u0001\u000c\u0001\u000e\u0001\u0016\u0001\u0035\u0001\u001f" +
                        "\u0001\u0020\u0001\u0003\u0001\u0001\u0001\u0006\u0001\u0002\u0001\u0011\u0001\u000f\u000a\u001b\u0001\u0004\u0001\u0005\u0001\u001e\u0001\u0015\u0001\u001e\u0001\u0007\u0001\u000b\u001a\u001a" +
                        "\u0001\u0008\u0001\u0010\u0001\u0009\u0001\u0033\u0001\u0012\u0001\u0033\u0001\u002f\u0001\u001a\u0001\u0031\u0001\u0036\u0001\u0028\u0001\u002c\u0001\u001a\u0001\u0024\u0001\u002b" +
                        "\u0002\u001a\u0001\u002e\u0001\u0030\u0001\u0026\u0001\u0025\u0001\u0021\u0001\u001a\u0001\u0029\u0001\u002a\u0001\u0023\u0001\u002d\u0001\u0027\u0001\u001a\u0001\u0032\u0001\u0022" +
                        "\u0001\u001a\u0001\u0013\u0001\u001c\u0001\u0014\u0001\u0017\u0006\u001d\u0001\u0019\u001a\u001d\u0001\u0000\u00df\u001d\u0001\u0000\u007f\u001d\u000b\u0000\u001d\u001d" +
                        "\u0002\u0019\u0005\u001d\u0001\u0000\u002f\u001d\u0001\u0000\u0020\u001d")
        /**
         * Translates DFA states to action switch labels.
         */
        private val ZZ_ACTION = zzUnpack()
        private const val ZZ_ACTION_PACKED_0 = "\u0008\u0000\u0001\u0001\u0002\u0002\u0001\u0003\u0001\u0002\u0001\u0004\u0001\u0005\u0001\u0004" +
                "\u0001\u0006\u0001\u0007\u0002\u0008\u0001\u0009\u0001\u000a\u0001\u0002\u0001\u000b\u0001\u0002" +
                "\u0001\u000c\u0001\u000d\u0001\u000e\u0007\u0002\u0001\u000f\u0001\u0010\u0001\u0001\u0001\u0011" +
                "\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001\u0016\u0001\u0017\u0001\u0018\u0001\u0019" +
                "\u0001\u001a\u0001\u001b\u0001\u001c\u0001\u001d\u0001\u001e\u0001\u001f\u0001\u0020\u0001\u0021" +
                "\u0001\u0022\u0001\u0023\u0001\u0001\u0001\u0024\u0001\u0025\u0001\u0002\u0001\u0026\u0001\u0027" +
                "\u0001\u0002\u0001\u0028\u0001\u0029\u0002\u002a\u0001\u002b\u0001\u002c\u0001\u002d\u0001\u002e" +
                "\u0001\u0000\u0001\u000c\u0002\u0000\u0001\u002f\u0004\u0000\u0001\u0030\u0002\u0000\u0001\u0029" +
                "\u0004\u0000\u0001\u0031\u0003\u0000\u0001\u0032\u0009\u0000\u0001\u0033\u0043\u0000"

        private fun zzUnpack(): IntArray {
            val result = IntArray(171)
            zzUnpack(ZZ_ACTION_PACKED_0, 0, result)
            return result
        }

        private fun zzUnpack(packed: String, offset: Int, result: IntArray): Int {
            var index = 0       /* index in packed string  */
            var unpackedIndex = offset  /* index in unpacked array */
            val length = packed.length
            while (index < length) {
                var count = packed[index++].toInt()
                val value = packed[index++].toInt()
                do result[unpackedIndex++] = value while (--count > 0)
            }
            return unpackedIndex
        }


        /**
         * Translates a state to a row index in the transition table
         */
        private val ZZ_ROWMAP = zzUnpackRowMap()
        private const val ZZ_ROWMAP_PACKED_0 = "\u0000\u0000\u0000\u0037\u0000\u006e\u0000\u00a5\u0000\u00dc\u0000\u0113\u0000\u014a\u0000\u0181" +
                "\u0000\u01b8\u0000\u01ef\u0000\u0226\u0000\u025d\u0000\u0294\u0000\u01ef\u0000\u01ef\u0000\u02cb" +
                "\u0000\u0302\u0000\u0339\u0000\u0370\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u03a7\u0000\u03de" +
                "\u0000\u0415\u0000\u03a7\u0000\u01ef\u0000\u01ef\u0000\u044c\u0000\u0483\u0000\u04ba\u0000\u04f1" +
                "\u0000\u0528\u0000\u055f\u0000\u0596\u0000\u01ef\u0000\u01ef\u0000\u05cd\u0000\u01ef\u0000\u01ef" +
                "\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u01ef" +
                "\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u01ef" +
                "\u0000\u01ef\u0000\u0604\u0000\u01ef\u0000\u01ef\u0000\u063b\u0000\u01ef\u0000\u01ef\u0000\u0672" +
                "\u0000\u06a9\u0000\u063b\u0000\u01ef\u0000\u0294\u0000\u01ef\u0000\u01ef\u0000\u01ef\u0000\u01ef" +
                "\u0000\u02cb\u0000\u01ef\u0000\u06e0\u0000\u0717\u0000\u01ef\u0000\u074e\u0000\u0785\u0000\u07bc" +
                "\u0000\u07f3\u0000\u01ef\u0000\u082a\u0000\u0861\u0000\u01ef\u0000\u0898\u0000\u08cf\u0000\u0906" +
                "\u0000\u093d\u0000\u01ef\u0000\u0974\u0000\u09ab\u0000\u09e2\u0000\u01ef\u0000\u0a19\u0000\u0a50" +
                "\u0000\u0a87\u0000\u0abe\u0000\u0af5\u0000\u0b2c\u0000\u0b63\u0000\u0b9a\u0000\u0bd1\u0000\u01ef" +
                "\u0000\u0c08\u0000\u0c3f\u0000\u0c76\u0000\u0cad\u0000\u0ce4\u0000\u0d1b\u0000\u0d52\u0000\u0d89" +
                "\u0000\u0dc0\u0000\u0df7\u0000\u0e2e\u0000\u0e65\u0000\u0e9c\u0000\u0ed3\u0000\u0f0a\u0000\u0f41" +
                "\u0000\u0f78\u0000\u0faf\u0000\u0fe6\u0000\u101d\u0000\u1054\u0000\u108b\u0000\u10c2\u0000\u10f9" +
                "\u0000\u1130\u0000\u1167\u0000\u119e\u0000\u11d5\u0000\u120c\u0000\u1243\u0000\u127a\u0000\u12b1" +
                "\u0000\u12e8\u0000\u131f\u0000\u1356\u0000\u138d\u0000\u13c4\u0000\u13fb\u0000\u1432\u0000\u1469" +
                "\u0000\u14a0\u0000\u14d7\u0000\u150e\u0000\u1545\u0000\u157c\u0000\u15b3\u0000\u15ea\u0000\u1621" +
                "\u0000\u1658\u0000\u168f\u0000\u16c6\u0000\u16fd\u0000\u1734\u0000\u176b\u0000\u17a2\u0000\u17d9" +
                "\u0000\u1810\u0000\u1847\u0000\u187e\u0000\u18b5\u0000\u18ec\u0000\u1923\u0000\u195a\u0000\u1991" +
                "\u0000\u19c8\u0000\u19ff\u0000\u1a36"

        private fun zzUnpackRowMap(): IntArray {
            val result = IntArray(171)
            zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, 0, result)
            return result
        }

        private fun zzUnpackRowMap(packed: String, offset: Int, result: IntArray): Int {
            var i = 0  /* index in packed string  */
            var j = offset  /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                val high = packed[i++].toInt() shl 16
                result[j++] = high or packed[i++].toInt()
            }
            return j
        }

        /**
         * The transition table of the DFA
         */
        private val ZZ_TRANS = zzUnpackTrans()
        private const val ZZ_TRANS_PACKED_0 = "\u0001\u0009\u0001\u000a\u0001\u000b\u000a\u000a\u0001\u000c\u0002\u000a\u0001\u000d\u0001\u000e" +
                "\u0006\u000a\u0001\u000f\u0001\u0009\u0002\u0010\u0001\u000f\u0004\u000a\u0012\u0010\u0003\u000a" +
                "\u0001\u0010\u0001\u0009\u0003\u0011\u0006\u000a\u0001\u0011\u0002\u000a\u0001\u0012\u0002\u000a" +
                "\u0001\u000d\u0002\u0011\u0005\u000a\u0001\u000f\u0001\u0009\u0002\u0011\u0001\u000f\u0004\u000a" +
                "\u0012\u0011\u0003\u000a\u0001\u0011\u0001\u0013\u000f\u0014\u0001\u000d\u0007\u0014\u0001\u000f" +
                "\u0001\u0013\u0003\u0014\u0001\u000a\u0016\u0014\u0001\u0015\u0001\u000a\u0001\u0014\u0001\u0013" +
                "\u000f\u0014\u0001\u000d\u0007\u0014\u0001\u000f\u0001\u0013\u0003\u0014\u0001\u000a\u0016\u0014" +
                "\u0001\u000a\u0001\u0016\u0001\u0014\u0001\u0009\u0009\u000a\u0001\u0017\u0002\u000a\u0001\u0018" +
                "\u0002\u000a\u0001\u000d\u0004\u000a\u0001\u0019\u0001\u000a\u0001\u0017\u0001\u000f\u0001\u0009" +
                "\u0002\u000a\u0001\u000f\u0001\u000a\u0001\u001a\u0001\u001b\u0001\u001c\u0001\u001d\u0003\u000a" +
                "\u0001\u001e\u0001\u001f\u0001\u000a\u0001\u0020\u0001\u000a\u0001\u0021\u0001\u0022\u0003\u000a" +
                "\u0001\u0023\u0004\u000a\u0001\u0024\u0001\u0025\u0001\u000a\u0001\u0026\u0001\u0027\u0001\u0028" +
                "\u0001\u0029\u0001\u002a\u0002\u0029\u0001\u002b\u0001\u002c\u0001\u002d\u0001\u0029\u0001\u002e" +
                "\u0001\u002f\u0001\u0030\u0001\u0031\u0001\u0032\u0001\u000d\u0001\u0033\u0001\u0034\u0001\u0035" +
                "\u0001\u0036\u0002\u0029\u0001\u0037\u0001\u000f\u0001\u0026\u0001\u0038\u0001\u0039\u0001\u000f" +
                "\u0002\u000a\u0002\u0029\u0012\u0038\u0002\u000a\u0001\u0029\u0001\u0038\u0001\u003a\u0004\u000a" +
                "\u0001\u003b\u0001\u003c\u0001\u000a\u0001\u002c\u0001\u002d\u0001\u003d\u0001\u003e\u0004\u000a" +
                "\u0001\u000d\u0001\u003f\u0003\u000a\u0001\u0040\u0001\u000a\u0001\u003d\u0001\u000f\u0001\u003a" +
                "\u0002\u0041\u0001\u000f\u0001\u000a\u0001\u0042\u0001\u001b\u0001\u001c\u0012\u0041\u0003\u000a" +
                "\u0001\u0041\u0001\u0009\u000f\u0043\u0001\u0044\u0008\u0043\u0001\u0009\u001d\u0043\u0001\u0009" +
                "\u0018\u0000\u0001\u0009\u007c\u0000\u0001\u0045\u0001\u0046\u000d\u0000\u0018\u000c\u0002\u0000" +
                "\u001d\u000c\u0010\u0000\u0001\u0047\u0007\u0000\u0001\u0048\u0003\u0000\u0001\u0048\u001c\u0000" +
                "\u0001\u0049\u000e\u0000\u0002\u0049\u0007\u0000\u0002\u0010\u0005\u0000\u0012\u0010\u0003\u0000" +
                "\u0001\u0010\u0001\u0000\u0003\u0011\u0006\u0000\u0001\u0011\u0006\u0000\u0002\u0011\u0007\u0000" +
                "\u0002\u0011\u0005\u0000\u0012\u0011\u0003\u0000\u0001\u0011\u0018\u0012\u0002\u0000\u001d\u0012" +
                "\u0001\u0013\u0018\u0000\u0001\u0013\u0032\u0000\u0001\u004a\u0021\u0000\u0018\u0018\u0002\u0000" +
                "\u001d\u0018\u0015\u0000\u0001\u001a\u0043\u0000\u0001\u004b\u000b\u0000\u0001\u004c\u0031\u0000" +
                "\u0001\u004d\u0001\u004e\u0031\u0000\u0001\u004f\u0043\u0000\u0001\u0050\u0026\u0000\u0001\u0051" +
                "\u003a\u0000\u0001\u0052\u0009\u0000\u0001\u0053\u002c\u0000\u0001\u0054\u0010\u0000\u0001\u0026" +
                "\u0004\u0000\u0001\u003b\u0007\u0000\u0001\u0018\u000b\u0000\u0001\u0026\u001d\u0000\u0001\u003a" +
                "\u000c\u0000\u0001\u0018\u000b\u0000\u0001\u003a\u0032\u0000\u0001\u0055\u0036\u0000\u0001\u0042" +
                "\u0022\u0000\u0001\u003f\u0001\u0056\u0001\u0000\u0001\u003f\u000c\u0000\u0002\u0056\u0007\u0000" +
                "\u0002\u0041\u0005\u0000\u0012\u0041\u0003\u0000\u0001\u0041\u0023\u0000\u0001\u0057\u0042\u0000" +
                "\u0001\u0058\u0019\u0000\u0001\u0059\u0047\u0000\u0001\u005a\u0036\u0000\u0001\u005b\u003d\u0000" +
                "\u0001\u005c\u002d\u0000\u0001\u005d\u004b\u0000\u0001\u005e\u0002\u0000\u0001\u0056\u000e\u0000" +
                "\u0002\u0056\u0007\u0000\u0002\u0041\u0005\u0000\u0012\u0041\u0003\u0000\u0001\u0041\u0024\u0000" +
                "\u0001\u005f\u0035\u0000\u0001\u0060\u0039\u0000\u0001\u0061\u0039\u0000\u0001\u0062\u001f\u0000" +
                "\u0001\u0063\u0052\u0000\u0001\u0064\u002d\u0000\u0001\u0065\u003d\u0000\u0001\u0066\u0039\u0000" +
                "\u0001\u0067\u0036\u0000\u0001\u0068\u0028\u0000\u0001\u0069\u003d\u0000\u0001\u006a\u0034\u0000" +
                "\u0001\u006b\u0035\u0000\u0001\u006c\u0041\u0000\u0001\u006d\u0034\u0000\u0001\u006e\u0038\u0000" +
                "\u0001\u006f\u0018\u0000\u0001\u0070\u004d\u0000\u0001\u0071\u0035\u0000\u0001\u0068\u003d\u0000" +
                "\u0001\u0072\u002f\u0000\u0001\u0073\u0035\u0000\u0001\u0074\u0004\u0000\u0001\u0075\u003a\u0000" +
                "\u0001\u0076\u0029\u0000\u0001\u0077\u0039\u0000\u0001\u0078\u0038\u0000\u0001\u0079\u003b\u0000" +
                "\u0001\u007a\u001b\u0000\u0001\u007b\u0050\u0000\u0001\u007c\u002d\u0000\u0001\u007d\u003c\u0000" +
                "\u0001\u007e\u003b\u0000\u0001\u007f\u0029\u0000\u0001\u0080\u0005\u0000\u0001\u0074\u0001\u0000" +
                "\u0001\u0081\u0001\u0082\u0005\u0000\u0001\u0083\u002b\u0000\u0001\u0084\u0040\u0000\u0001\u0085" +
                "\u0031\u0000\u0001\u0086\u003a\u0000\u0001\u0087\u002a\u0000\u0001\u0088\u003c\u0000\u0001\u0089" +
                "\u0030\u0000\u0001\u008a\u0043\u0000\u0001\u008b\u0030\u0000\u0001\u008c\u0030\u0000\u0001\u008d" +
                "\u003e\u0000\u0001\u008e\u001d\u0000\u0001\u008f\u0047\u0000\u0001\u0090\u0041\u0000\u0001\u0091" +
                "\u0032\u0000\u0001\u0092\u003d\u0000\u0001\u0093\u0035\u0000\u0001\u0068\u0031\u0000\u0001\u0094" +
                "\u0030\u0000\u0001\u0095\u0038\u0000\u0001\u0074\u0033\u0000\u0001\u0096\u003a\u0000\u0001\u0097" +
                "\u0031\u0000\u0001\u0098\u0037\u0000\u0001\u0099\u0037\u0000\u0001\u009a\u0037\u0000\u0001\u0068" +
                "\u0035\u0000\u0001\u009b\u0040\u0000\u0001\u009c\u002f\u0000\u0001\u008c\u0039\u0000\u0001\u009d" +
                "\u0031\u0000\u0001\u009e\u0036\u0000\u0001\u009f\u003a\u0000\u0001\u006d\u0032\u0000\u0001\u006d" +
                "\u0022\u0000\u0001\u00a0\u0036\u0000\u0001\u00a1\u004a\u0000\u0001\u0061\u0001\u0074\u003a\u0000" +
                "\u0001\u00a2\u003b\u0000\u0001\u00a3\u0027\u0000\u0001\u00a4\u0043\u0000\u0001\u00a5\u0030\u0000" +
                "\u0001\u00a6\u003e\u0000\u0001\u00a7\u002e\u0000\u0001\u00a8\u0034\u0000\u0001\u00a9\u0033\u0000" +
                "\u0001\u00aa\u0042\u0000\u0001\u00ab\u002a\u0000\u0001\u0086\u0013\u0000"

        private fun zzUnpackTrans(): IntArray {
            val result = IntArray(6765)
            zzUnpackTrans(ZZ_TRANS_PACKED_0, 0, result)
            return result
        }

        private fun zzUnpackTrans(packed: String, offset: Int, result: IntArray): Int {
            var i = 0       /* index in packed string  */
            var j = offset  /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].toInt()
                var value = packed[i++].toInt()
                value--
                do result[j++] = value while (--count > 0)
            }
            return j
        }


        /* error codes */
        private const val ZZ_UNKNOWN_ERROR = 0
        private const val ZZ_NO_MATCH = 1
        private const val ZZ_PUSHBACK_2BIG = 2

        /* error messages for the codes above */
        private val ZZ_ERROR_MSG = arrayOf(
                "Unknown internal scanner error",
                "Error: could not match input",
                "Error: pushback value was too large"
        )

        /**
         * ZZ_ATTRIBUTE[aState] contains the attributes of state `aState`
         */
        private val ZZ_ATTRIBUTE = zzUnpackAttribute()
        private const val ZZ_ATTRIBUTE_PACKED_0 = "\u0008\u0000\u0001\u0001\u0001\u0009\u0003\u0001\u0002\u0009\u0004\u0001\u0003\u0009\u0004\u0001" +
                "\u0002\u0009\u0007\u0001\u0002\u0009\u0001\u0001\u0013\u0009\u0001\u0001\u0002\u0009\u0001\u0001" +
                "\u0002\u0009\u0003\u0001\u0001\u0009\u0001\u0001\u0004\u0009\u0001\u0000\u0001\u0009\u0002\u0000" +
                "\u0001\u0009\u0004\u0000\u0001\u0009\u0002\u0000\u0001\u0009\u0004\u0000\u0001\u0009\u0003\u0000" +
                "\u0001\u0009\u0009\u0000\u0001\u0009\u0043\u0000"

        private fun zzUnpackAttribute(): IntArray {
            val result = IntArray(171)
            zzUnpack(ZZ_ATTRIBUTE_PACKED_0, 0, result)
            return result
        }

        /**
         * Unpacks the compressed character translation table.
         *
         * @param packed   the packed character translation table
         * @return         the unpacked character translation table
         */
        private fun zzUnpackCMap(packed: String): CharArray {
            var size = 0
            var k = 0
            val length = packed.length
            while (k < length) {
                size += packed[k].toInt()
                k += 2
            }
            val map = CharArray(size)
            var i = 0  /* index in packed string  */
            var j = 0  /* index in unpacked array */
            while (i < packed.length) {
                var count = packed[i++].toInt()
                val value = packed[i++]
                do map[j++] = value while (--count > 0)
            }
            return map
        }
    }
}
